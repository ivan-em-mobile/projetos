<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Tetris Moderno</title>
<style>
  /* Reset básico */
  * {
    box-sizing: border-box;
    margin: 0; padding: 0;
    -webkit-tap-highlight-color: transparent;
  }
  body {
    background: #121212;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #eee;
  }
  #tetris-container {
    background: #222;
    width: 360px;
    height: 620px;
    border-radius: 10px;
    box-shadow: 0 0 15px rgb(176, 214, 6);
    display: flex;
    flex-direction: column;
    padding: 20px;
  }
  #game {
    position: relative;
    width: 320px;
    height: 520px;
    background: #111111c1;
    border-radius: 8px;
    box-shadow:
      inset 0 0 05px #00f,
      0 0 05px #00f;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    display: block;
    margin: auto;
    background: #111;
  }
  #info {
    margin-top: 10px;
    display: flex;
    justify-content: space-between;
    font-size: 16px;
    user-select: none;
  }
  #score, #level {
    font-weight: bold;
    color: #0ff;
  }
  #controls {
    margin-top: 10px;
    display: flex;
    justify-content: space-between;
  }
  button.control-btn {
    background: #0af;
    border: none;
    color: white;
    font-size: 18px;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    user-select: none;
    flex: 1;
    margin: 0 3px;
    box-shadow: 0 4px #058;
    transition: background 0.3s ease;
    touch-action: manipulation;
  }
  button.control-btn:active {
    background: #05a;
    box-shadow: 0 2px #024;
    transform: translateY(2px);
  }
  @media (max-width: 350px) {
    #tetris-container {
      width: 100vw;
      max-width: 350px;
      height: 600px;
      padding: 8px;
      box-shadow: none;
      border-radius: 0;
    }
    #game {
      width: 100vw;
      max-width: 350px;
      height: 520px;
      border-radius: 0;
    }
    button.control-btn {
      font-size: 16px;
      padding: 8px 10px;
    }
  }
</style>
</head>
<body>
  <div id="tetris-container" role="main" aria-label="Jogo de Tetris">
    <div id="game">
      <canvas id="tetris" width="360" height="580" aria-label="Campo do jogo Tetris"></canvas>
    </div>
    <div id="info">
      <div>Pontuação: <span id="score">0</span></div>
      <div>Nível: <span id="level">1</span></div>
    </div>
    <div id="controls" aria-label="Controles do jogo">
      <button class="control-btn" id="left-btn" aria-label="Mover para esquerda">←</button>
      <button class="control-btn" id="rotate-btn" aria-label="Rotacionar peça">⟳</button>
      <button class="control-btn" id="right-btn" aria-label="Mover para direita">→</button>
      <button class="control-btn" id="down-btn" aria-label="Mover para baixo mais rápido">↓</button>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('tetris');
      const ctx = canvas.getContext('2d');
      const ROWS = 20;
      const COLS = 10;
      const BLOCK_SIZE = 26;
      const WIDTH = COLS * BLOCK_SIZE; // 260 px (canvas is 320px wide: center via margin)
      const HEIGHT = ROWS * BLOCK_SIZE; // 520 px (canvas height)
      
      // Ajusta canvas para centralizar a grade (largura 260px centralizado em 320)
      canvas.style.width = WIDTH + 'px';
      canvas.style.height = HEIGHT + 'px';

      const colors = [
        null,
        '#00f0f0', // I - ciano
        '#0000f0', // J - azul
        '#f0a000', // L - laranja
        '#f0f000', // O - amarelo
        '#00f000', // S - verde
        '#a000f0', // T - roxo
        '#f00000'  // Z - vermelho
      ];

      // Definição das peças e suas rotações (4 estados cada)
      const PIECES = {
        I: [
          [[0,0,0,0],
           [1,1,1,1],
           [0,0,0,0],
           [0,0,0,0]],
          [[0,0,1,0],
           [0,0,1,0],
           [0,0,1,0],
           [0,0,1,0]],
          [[0,0,0,0],
           [0,0,0,0],
           [1,1,1,1],
           [0,0,0,0]],
          [[0,1,0,0],
           [0,1,0,0],
           [0,1,0,0],
           [0,1,0,0]],
        ],
        J: [
          [[2,0,0],
           [2,2,2],
           [0,0,0]],
          [[0,2,2],
           [0,2,0],
           [0,2,0]],
          [[0,0,0],
           [2,2,2],
           [0,0,2]],
          [[0,2,0],
           [0,2,0],
           [2,2,0]],
        ],
        L: [
          [[0,0,3],
           [3,3,3],
           [0,0,0]],
          [[0,3,0],
           [0,3,0],
           [0,3,3]],
          [[0,0,0],
           [3,3,3],
           [3,0,0]],
          [[3,3,0],
           [0,3,0],
           [0,3,0]],
        ],
        O: [
          [[4,4],
           [4,4]],
          [[4,4],
           [4,4]],
          [[4,4],
           [4,4]],
          [[4,4],
           [4,4]],
        ],
        S: [
          [[0,5,5],
           [5,5,0],
           [0,0,0]],
          [[0,5,0],
           [0,5,5],
           [0,0,5]],
          [[0,0,0],
           [0,5,5],
           [5,5,0]],
          [[5,0,0],
           [5,5,0],
           [0,5,0]],
        ],
        T: [
          [[0,6,0],
           [6,6,6],
           [0,0,0]],
          [[0,6,0],
           [0,6,6],
           [0,6,0]],
          [[0,0,0],
           [6,6,6],
           [0,6,0]],
          [[0,6,0],
           [6,6,0],
           [0,6,0]],
        ],
        Z: [
          [[7,7,0],
           [0,7,7],
           [0,0,0]],
          [[0,0,7],
           [0,7,7],
           [0,7,0]],
          [[0,0,0],
           [7,7,0],
           [0,7,7]],
          [[0,7,0],
           [7,7,0],
           [7,0,0]],
        ],
      };

      // O tabuleiro é uma matriz ROWS x COLS inicializada com zeros
      function createMatrix(w, h) {
        const matrix = [];
        while(h--) {
          matrix.push(new Array(w).fill(0));
        }
        return matrix;
      }

      // Função para desenhar uma matriz no canvas, na posição x,y (em blocos)
      function drawMatrix(matrix, offset) {
        matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if(value !== 0) {
              ctx.fillStyle = colors[value];
              ctx.fillRect(
                (x + offset.x) * BLOCK_SIZE,
                (y + offset.y) * BLOCK_SIZE,
                BLOCK_SIZE - 1,
                BLOCK_SIZE - 1
              );
              ctx.strokeStyle = '#222';
              ctx.lineWidth = 1;
              ctx.strokeRect(
                (x + offset.x) * BLOCK_SIZE + 1,
                (y + offset.y) * BLOCK_SIZE + 1,
                BLOCK_SIZE - 3,
                BLOCK_SIZE - 3
              );
            }
          });
        });
      }

      // Função para desenhar o tabuleiro inteiro e a peça atual
      function draw() {
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawMatrix(arena, {x:0, y:0});
        drawMatrix(player.matrix, player.pos);
      }

      // Verifica colisão entre jogador e arena
      function collide(arena, player) {
        const m = player.matrix;
        const o = player.pos;
        for(let y = 0; y < m.length; ++y) {
          for(let x = 0; x < m[y].length; ++x) {
            if(m[y][x] !== 0 &&
               (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
              return true;
            }
          }
        }
        return false;
      }

      // Mescla peça do jogador na arena
      function merge(arena, player) {
        player.matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if(value !== 0) {
              arena[y + player.pos.y][x + player.pos.x] = value;
            }
          });
        });
      }

      // Rotaciona a matriz da peça
      function rotate(matrix, dir) {
        for(let y = 0; y < matrix.length; ++y) {
          for(let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
          }
        }
        if(dir > 0) {
          matrix.forEach(row => row.reverse());
        } else {
          matrix.reverse();
        }
      }

      // Função para girar a peça atualmente selecionada com ajuste de colisão
      function playerRotate(dir) {
        const pos = player.pos.x;
        let offset = 1;
        rotate(player.matrix, dir);
        while(collide(arena, player)) {
          player.pos.x += offset;
          offset = -(offset + (offset > 0 ? 1 : -1));
          if(offset > player.matrix[0].length) {
            rotate(player.matrix, -dir);
            player.pos.x = pos;
            return;
          }
        }
      }

      // Remove linhas completas da arena e atualiza pontuação
      function arenaSweep() {
        let rowCount = 0;
        outer: for(let y = arena.length - 1; y >= 0; --y) {
          for(let x = 0; x < arena[y].length; ++x) {
            if(arena[y][x] === 0) {
              continue outer;
            }
          }
          // remove a linha e insere uma nova no topo
          const row = arena.splice(y, 1)[0].fill(0);
          arena.unshift(row);
          ++y;
          rowCount++;
        }
        if(rowCount > 0) {
          // Pontuação inspirada no original Tetris
          player.score += rowCount * 10 * rowCount;
          document.getElementById('score').textContent = player.score;
          // Incrementa nível a cada 100 pontos
          let newLevel = Math.floor(player.score / 100) + 1;
          if(newLevel > player.level) {
            player.level = newLevel;
            dropInterval = Math.max(100, baseDropInterval - (player.level - 1) * 100);
            document.getElementById('level').textContent = player.level;
          }
        }
      }

      // Gera uma peça aleatória
      function createPiece(type) {
        // copia a matriz da peça na rotação 0 do tipo
        return PIECES[type][0].map(row => row.slice());
      }

      // Função para gera aleatoriamente o próximo tetromino
      function randomPiece() {
        const pieces = 'TJLOSZI';
        const type = pieces[Math.floor(Math.random() * pieces.length)];
        return {type, matrix: createPiece(type), rotation: 0};
      }

      // Inicializa o jogo e jogador
      function playerReset() {
        const next = nextPiece;
        player.type = next.type;
        player.matrix = PIECES[player.type][0].map(row => row.slice());
        player.pos.y = 0;
        player.pos.x = Math.floor((COLS - player.matrix[0].length) / 2);
        player.rotation = 0;
        nextPiece = randomPiece();
        if(collide(arena, player)) {
          arena.forEach(row => row.fill(0));
          player.score = 0;
          player.level = 1;
          dropInterval = baseDropInterval;
          document.getElementById('score').textContent = player.score;
          document.getElementById('level').textContent = player.level;
        }
      }

      // Atualiza a posição da peça (drop)
      function playerDrop() {
        player.pos.y++;
        if(collide(arena, player)) {
          player.pos.y--;
          merge(arena, player);
          arenaSweep();
          playerReset();
          dropCounter = 0;
        }
      }

      // Move peça para esquerda ou direita
      function playerMove(dir) {
        player.pos.x += dir;
        if(collide(arena, player)) {
          player.pos.x -= dir;
        }
      }

      // Rotaciona peça (direita)
      function playerRotateRight() {
        player.rotation = (player.rotation + 1) % 4;
        playerRotate(1);
      }

      // Variáveis de controle do tempo de queda automático
      let dropCounter = 0;
      let dropInterval = 1000; // intervalo inicial de queda 1 segundo
      const baseDropInterval = 1000;
      let lastTime = 0;
      let nextPiece = randomPiece();

      const arena = createMatrix(COLS, ROWS);
      const player = {
        pos: {x: 0, y: 0},
        matrix: null,
        score: 0,
        level: 1,
        rotation: 0,
        type: null
      };

      playerReset();

      // Loop principal de atualização
      function update(time = 0) {
        const deltaTime = time - lastTime;
        lastTime = time;
        dropCounter += deltaTime;
        if(dropCounter > dropInterval) {
          playerDrop();
          dropCounter = 0;
        }
        draw();
        requestAnimationFrame(update);
      }

      // Tratamento teclado
      document.addEventListener('keydown', event => {
        if(event.repeat) return; // evita aceleração por tecla pressionada
        switch(event.key) {
          case 'ArrowLeft':
          case 'a':
          case 'A':
            playerMove(-1);
            break;
          case 'ArrowRight':
          case 'd':
          case 'D':
            playerMove(1);
            break;
          case 'ArrowDown':
          case 's':
          case 'S':
            playerDrop();
            break;
          case 'ArrowUp':
          case 'w':
          case 'W':
          case 'x':
          case 'X':
            playerRotateRight();
            break;
          case ' ':
            // Drop instantâneo não implementado para simplicidade
            break;
        }
      });

      // Controles touch buttons para mobile
      document.getElementById('left-btn').addEventListener('touchstart', e => {
        e.preventDefault();
        playerMove(-1);
      });
      document.getElementById('right-btn').addEventListener('touchstart', e => {
        e.preventDefault();
        playerMove(1);
      });
      document.getElementById('down-btn').addEventListener('touchstart', e => {
        e.preventDefault();
        playerDrop();
      });
      document.getElementById('rotate-btn').addEventListener('touchstart', e => {
        e.preventDefault();
        playerRotateRight();
      });

      // Também ativar click para desktop dos botões
      ['left-btn', 'right-btn', 'down-btn', 'rotate-btn'].forEach(id => {
        const btn = document.getElementById(id);
        btn.addEventListener('click', e => {
          e.preventDefault();
          switch(id) {
            case 'left-btn':
              playerMove(-1);
              break;
            case 'right-btn':
              playerMove(1);
              break;
            case 'down-btn':
              playerDrop();
              break;
            case 'rotate-btn':
              playerRotateRight();
              break;
          }
        });
      });

      update();
    })();
  </script>
</body>
</html>

